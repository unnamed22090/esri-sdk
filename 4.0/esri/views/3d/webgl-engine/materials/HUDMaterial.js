// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See http://js.arcgis.com/4.0/esri/copyright.txt for details.
//>>built
require({cache:{"url:esri/views/3d/webgl-engine/materials/HUDMaterial.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\r\n\r\n\x3csnippets\x3e\r\n\r\n\x3csnippet name\x3d"HUDMaterialCommonVariables"\x3e\x3c![CDATA[\r\n\tuniform mat4 proj;\r\n\tuniform mat4 view;\r\n\tuniform mat4 model;\r\n\tuniform mat4 modelNormal;\r\n\tuniform vec4 viewport;\r\n\tuniform vec3 camPos;\r\n\tuniform float pixelRatio;\r\n\tuniform vec2 screenOffset;\r\n\tuniform vec2 anchorPos;\r\n\tuniform float polygonOffset;\r\n\r\n\tattribute vec3 $position;\r\n\tattribute vec3 $normal;\r\n\tattribute vec2 $uv0;\r\n\tattribute vec4 $color;\r\n  attribute vec2 $size;\r\n  attribute vec4 $auxpos1;\r\n\r\n\tvarying vec4 vcolor;\r\n\t\r\n#ifdef OCCL_PIXELSHADER\r\n \tvarying vec4 vtc;\r\n#else\r\n\tvarying vec2 vtc;\r\n\tvarying vec2 vsize;\r\n\tuniform sampler2D framebufferTex;\r\n\tuniform vec3 markerColor;\r\n#endif\t\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"matchPixelOrigin"\x3e\x3c![CDATA[\r\n\tvec4 matchPixelOrigin(vec4 clipCoord, vec2 widthHeight) {\r\n\t\tvec2 xy \x3d vec2(.5) + .5 * clipCoord.xy / clipCoord.w;\r\n\t\tvec2 pixelSz \x3d vec2(1.0) / widthHeight;\r\n\t\tvec2 ij \x3d floor((xy + .5 * pixelSz) * widthHeight);\r\n\t\tvec2 result \x3d ((ij * pixelSz) * 2.0 - vec2(1.0)) * clipCoord.w;\r\n\t\treturn vec4(result.x, result.y, clipCoord.z, clipCoord.w);\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"calcPosMatchPixelCenter"\x3e\x3c![CDATA[\r\n\r\n\t\tvec3 posModel \x3d (model * vec4($position, 1.0)).xyz;\r\n\t\tvec3 posView \x3d (view * vec4(posModel, 1.0)).xyz;\r\n\r\n\t\tvec3 vnormal \x3d (modelNormal * vec4($normal, 1.0)).xyz;\r\n\r\n\t\t// view angle dependent part of polygon offset emulation\r\n\t\tfloat cosAlpha \x3d dot(vnormal, normalize(camPos - posModel));\r\n\t\tif (cosAlpha \x3e .01 \x26\x26 polygonOffset \x3e .0) {\r\n\t\t\tfloat tanAlpha \x3d sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;\r\n\t\t\tposView *\x3d 1.0 - tanAlpha / viewport[2];\r\n\t\t}\r\n\r\n\t    if (centerOffset.w\x3c0.0)\r\n            posView+\x3dcenterOffset.xyz;\r\n\r\n\t\tvec4 posProj \x3d proj * vec4(posView, 1.0);\r\n\r\n\t\t// constant part of polygon offset emulation\r\n\t\tif (cosAlpha \x3e .01)\r\n\t\t\tposProj.z -\x3d polygonOffset * posProj.w;\r\n\r\n\t\tposProjCenter \x3d matchPixelCenter(posProj, viewport.zw);\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vertexShaderHUD"\x3e\x3c![CDATA[\r\n    $HUDMaterialCommonVariables\r\n\r\n\t$matchPixelCenter\r\n\t$matchPixelOrigin\r\n\r\n\tvoid main(void) {\r\n\r\n\t    vec4 centerOffset \x3d $auxpos1;\r\n\r\n\t\tvec2 combinedSize \x3d $size * pixelRatio;\r\n\r\n        vec4 posProjCenter;\r\n\t\t$calcPosMatchPixelCenter\r\n\r\n#ifdef OCCL_TEST\r\n\t\tif (texture2D(framebufferTex, .5 + .5 * posProjCenter.xy / posProjCenter.w).rgb \x3d\x3d markerColor) {\r\n#endif\r\n\t\t\tvec2 uv01 \x3d floor($uv0);\r\n\t\t\tvec2 uv \x3d $uv0 - uv01;\r\n\t\t\tfloat dist \x3d distance(camPos, posModel);\r\n\t\t\tposProj.xy +\x3d ((uv01 - anchorPos) * 2.0 * combinedSize + screenOffset)/ viewport.zw * posProj.w;\r\n\t\t\tvtc.xy \x3d uv;\r\n\t\t\tvsize \x3d $size;\r\n#ifdef OCCL_TEST\r\n\t\t} else {\r\n\t\t\tvtc \x3d vec2(.0);\r\n\t\t}\r\n#endif\r\n\r\n#ifdef OCCL_PIXELSHADER\r\n\tvtc.zw \x3d .5 + .5 * posProjCenter.xy / posProjCenter.w;\r\n#endif\r\n\t\tgl_Position \x3d matchPixelOrigin(posProj, viewport.zw);\r\n\t\tvcolor \x3d $color / 255.0;\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vertexShaderHUDWorldScale"\x3e\x3c![CDATA[\r\n    $HUDMaterialCommonVariables\r\n\r\n\tuniform vec2 minMaxWorldSizeFactor;\r\n\r\n\t$matchPixelCenter\r\n\t$matchPixelOrigin\r\n\r\n\tvoid main(void) {\r\n\t    vec4 centerOffset \x3d $auxpos1;\r\n\t    vec2 combinedSize \x3d $size * pixelRatio;\r\n\t    \r\n\t    vec4 posProjCenter;\r\n\r\n\t\t$calcPosMatchPixelCenter\r\n\r\n#ifdef OCCL_TEST\r\n\t\tif (texture2D(framebufferTex, .5 + .5 * posProjCenter.xy / posProjCenter.w).rgb \x3d\x3d markerColor) {\r\n#endif\r\n\t\t\tfloat scale \x3d 1.0;\r\n\t\t\tvec2 minMaxWorldSize \x3d distance(camPos, position)*minMaxWorldSizeFactor;\r\n\t\t\tif (minMaxWorldSize.x \x3e combinedSize.y)\r\n\t\t\t\tscale \x3d minMaxWorldSize.x / combinedSize.y;\r\n\t\t\telse if (minMaxWorldSize.y \x3e 0.0)\r\n\t\t\t\tscale \x3d min(1.0, minMaxWorldSize.y / combinedSize.y);\r\n\r\n\t\t\tvec2 uv01 \x3d floor($uv0);\r\n\t\t\tvec2 uv \x3d $uv0 - uv01;\r\n\t\t\tposView.xy +\x3d (uv01 - anchorPos) * combinedSize * scale;\r\n\t\t\tuv.y +\x3d (1.0 - texScale.y);\r\n\t\t\tvtc.xy \x3d uv;\r\n#ifdef OCCL_TEST\r\n\t\t} else {\r\n\t\t\tvtc \x3d vec2(.0);\r\n\t\t}\r\n#endif\r\n\r\n#ifdef OCCL_PIXELSHADER\r\n\tvtc.zw \x3d .5 + .5 * posProjCenter.xy / posProjCenter.w;\r\n#endif\r\n\t\tposProj \x3d proj * vec4(posView,1.0);\r\n\t\tposProj.xy +\x3d screenOffset / viewport.zw * posProj.w;\r\n\t\tgl_Position \x3d posProj;\r\n\t\tvcolor \x3d $color;\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\r\n\r\n\x3csnippet name\x3d"calcLabelDirections"\x3e\x3c![CDATA[\r\n\tvec2 uv01 \x3d floor($uv0);\r\n\tvec2 uv \x3d $uv0 - uv01;\r\n\r\n\tvec3 labelDir, labelDirOrtho;\r\n\r\n\tint isUp \x3d 0;\r\n\tvec2 vId \x3d (uv01 - vec2(.5, .5))*2.0;\r\n\r\n\tvec3 viewDirInNormalPlane \x3d normalize(camDir.xyz - dot(camDir.xyz, direction)*direction);\r\n\tfloat angleToNormal \x3d abs(dot(viewDirInNormalPlane,up));\r\n\tfloat angleToDirection \x3d abs(dot(camDir.xyz, direction));\r\n\tif (angleToDirection \x3c 0.985 \x26\x26 angleToNormal \x3c 0.500)\r\n\t{\r\n\t    if (angleToNormal \x3c 0.422) {\r\n\t\t    isUp \x3d 1;\r\n\t\t    labelDir \x3d direction;\r\n\t\t    labelDirOrtho \x3d up;\r\n\t\t    vId.y +\x3d 0.5;\r\n\t\t} else {\r\n\t\t    labelDir \x3d direction;\r\n            labelDirOrtho \x3d cross(viewDirInNormalPlane, direction);\r\n            vId.y +\x3d dot(labelDirOrtho, up)*0.5;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tlabelDir \x3d direction;\r\n\t\tlabelDirOrtho \x3d normalize(cross(up,direction));\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vertexShaderHUDDirection"\x3e\x3c![CDATA[\r\n \tuniform vec3 direction;\r\n \t\r\n\tvoid main(void) {\r\n\t    vec4 centerOffset \x3d $auxpos1;\r\n\t    vec2 combinedSize \x3d $size * pixelRatio;\r\n\r\n        vec4 posProjCenter;\r\n \t\t$calcPosMatchPixelCenter\r\n\r\n \t\tvec3 direction \x3d normalize(direction);\r\n \t\tvec3 up \x3d vnormal;\r\n \t\tvec3 camDir \x3d normalize(vec3(view[0][2],view[1][2],view[2][2]));\r\n\r\n #ifdef OCCL_TEST\r\n \t\tif (texture2D(framebufferTex, .5 + .5 * posProjCenter.xy / posProjCenter.w).rgb \x3d\x3d markerColor) {\r\n #endif\r\n\r\n \t\t\t$calcLabelDirections\r\n\r\n\t\t    float scale;\r\n\t\t    if (proj[2][3] !\x3d 0.0)  // perspective projection\r\n \t\t\t    scale \x3d posProj.w*0.5/viewport[2];\r\n \t\t\telse                    // othographic projection\r\n \t\t\t    scale \x3d 2.0/proj[0][0]/viewport[2];\r\n\r\n \t\t\tposModel.xyz +\x3d labelDir * vId.x * combinedSize.x * scale ;\r\n \t\t\tposModel.xyz +\x3d labelDirOrtho * vId.y * combinedSize.y * scale;\r\n\r\n \t\t\tvec4 posDirProj \x3d proj*view*model * vec4($position+direction, 1.0);\r\n \t\t\tvec4 posProjUnmodified \x3d proj*view*model * vec4($position, 1.0);\r\n \t\t\tif (posDirProj.x\x3cposProjUnmodified.x)\r\n \t\t\t{\r\n \t\t\t\tif (isUp\x3d\x3d1)\r\n \t\t\t\t\tuv.x \x3d texScale.x-uv.x;\r\n \t\t\t\telse\r\n \t\t\t\t\tuv \x3d texScale-uv;\r\n \t\t\t}\r\n \t\t\tvtc.xy \x3d uv;\r\n #ifdef OCCL_TEST\r\n \t\t} else {\r\n \t\t\tvtc \x3d vec2(.0);\r\n \t\t}\r\n #endif\r\n\r\n #ifdef OCCL_PIXELSHADER\r\n\tvtc.zw \x3d .5 + .5 * posProjCenter.xy / posProjCenter.w;\r\n#endif\r\n \t\tvec4 pos4 \x3d proj * view * vec4(posModel,1.0);\r\n \t\tgl_Position \x3d pos4;\r\n \t}\r\n ]]\x3e\x3c/snippet\x3e\r\n\r\n\r\n\x3csnippet name\x3d"vertexShaderHUDDirectionWorldScale"\x3e\x3c![CDATA[\r\n    $HUDMaterialCommonVariables\r\n    \r\n\tuniform vec2 minMaxWorldSizeFactor;\r\n\tuniform vec3 direction;\r\n\r\n\t$matchPixelCenter\r\n\t$matchPixelOrigin\r\n\r\n\tvoid main(void) {\r\n\t    vec4 centerOffset \x3d $auxpos1;\r\n\t    vec2 combinedSize \x3d $size * pixelRatio;\r\n\r\n        vec4 posProjCenter;\r\n\t\t$calcPosMatchPixelCenter\r\n\r\n\t\tvec3 direction \x3d normalize(direction);\r\n\t\tvec3 up \x3d vnormal;\r\n\t\tvec3 camDir \x3d normalize(vec3(view[0][2],view[1][2],view[2][2]));\r\n\r\n#ifdef OCCL_TEST\r\n\t\tif (texture2D(framebufferTex, .5 + .5 * posProjCenter.xy / posProjCenter.w).rgb \x3d\x3d markerColor) {\r\n#endif\r\n\r\n\t\t\t$calcLabelDirections\r\n\r\n\t\t\tfloat scale \x3d 1.0;\r\n\t\t\tvec2 minMaxWorldSize \x3d minMaxWorldSizeFactor;\r\n\t\t\tif (proj[2][3] !\x3d 0.0)  // perspective projection\r\n\t\t\t\tminMaxWorldSize \x3d distance(camPos, position)*minMaxWorldSizeFactor;\r\n\t\t\tif (minMaxWorldSize.x \x3e combinedSize.y)\r\n\t\t\t\tscale \x3d minMaxWorldSize.x / combinedSize.y;\r\n\t\t\telse if (minMaxWorldSize.y \x3e 0.0)\r\n\t\t\t\tscale \x3d min(1.0, minMaxWorldSize.y / combinedSize.y);\r\n\r\n\t\t\tposModel.xyz +\x3d labelDir*vId.x*combinedSize.x*scale;\r\n\t\t\tposModel.xyz +\x3d labelDirOrtho*vId.y*combinedSize.y*scale;\r\n\r\n\t\t\tvec4 posDirProj \x3d proj*view*model * vec4($position+direction, 1.0);\r\n\t\t\tvec4 posProjUnmodified \x3d proj*view*model * vec4($position, 1.0);\r\n \t\t\tif (posDirProj.x\x3cposProjUnmodified.x)\r\n \t\t\t{\r\n \t\t\t\tif (isUp\x3d\x3d1)\r\n \t\t\t\t\tuv.x \x3d texScale.x-uv.x;\r\n \t\t\t\telse\r\n \t\t\t\t\tuv \x3d texScale-uv;\r\n \t\t\t}\r\n \t\t\tuv.y +\x3d (1.0 - texScale.y);\r\n\t\t\tvtc.xy \x3d uv;\r\n#ifdef OCCL_TEST\r\n\t\t} else {\r\n\t\t\tvtc \x3d vec2(.0);\r\n\t\t}\r\n#endif\r\n\r\n#ifdef OCCL_PIXELSHADER\r\n\tvtc.zw \x3d .5 + .5 * posProjCenter.xy / posProjCenter.w;\r\n#endif\r\n\t\tvec4 pos4 \x3d proj * view * vec4(posModel,1.0);\r\n\t\tgl_Position \x3d pos4;\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fragmentShaderHUDBase"\x3e\x3c![CDATA[\r\n\tprecision mediump float;\r\n\r\n\t#extension GL_OES_standard_derivatives : require\r\n\r\n\tuniform sampler2D tex;\r\n\tuniform vec4 overrideColor;\r\n\tuniform vec4 outlineColor;\r\n\tuniform float outlineSize;\r\n\r\n\tvarying vec4 vcolor;\r\n\r\n#ifdef OCCL_PIXELSHADER\r\n\tvarying vec4 vtc;\r\n\tuniform vec3 markerColor;\r\n\tuniform sampler2D framebufferTex;\r\n#else\r\n\tvarying vec2 vtc;\r\n\tvarying vec2 vsize;\r\n#endif\r\n\r\n\tvoid main() {\r\n\r\n#ifdef OCCL_PIXELSHADER\r\n   \t\tif (texture2D(framebufferTex, vtc.zw).rgb !\x3d markerColor)\r\n   \t\t\tdiscard;\r\n#endif\r\n\r\n#ifdef SIGNED_DISTANCE_FIELD\r\n\t\tvec4 color \x3d vec4(0.0, 0.0, 0.0, 0.0);\r\n\t\tvec4 fillPixelColor \x3d overrideColor * vcolor;\r\n\r\n\t\t// Distance in [-0.5, 0.5]\r\n\t\tfloat d \x3d dot(texture2D(tex, vtc), vec4(1.0/16777216.0, 1.0/65535.0, 1.0/256.0, 1.0)) - 0.5;\r\n\t\t// Distance in output units\r\n\t\tfloat dist \x3d d * vsize.x;\r\n\r\n\t\tfillPixelColor.a *\x3d clamp(0.5 - dist, 0.0, 1.0);\r\n\r\n\t\tif (outlineSize \x3e 0.25) {\r\n\t\t\tvec4 outlinePixelColor \x3d outlineColor;\r\n\t\t\tfloat clampedOutlineSize \x3d min(outlineSize, 0.5*vsize.x);\r\n\t\t\toutlinePixelColor.a *\x3d clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);\r\n\r\n\t\t\t// perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)\r\n\t\t\tfloat compositeAlpha \x3d outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);\r\n\t\t\tvec3 compositeColor \x3d vec3(outlinePixelColor) * outlinePixelColor.a +\r\n\t\t\t\tvec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);\r\n\t\t\tcompositeColor /\x3d compositeAlpha;\r\n\r\n\t\t\tgl_FragColor \x3d vec4(compositeColor, compositeAlpha);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tgl_FragColor \x3d fillPixelColor;\r\n\t\t}\r\n\r\n\t\t// visualize SDF:\r\n\t\t// gl_FragColor \x3d vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);\r\n#else\r\n\t\tgl_FragColor \x3d texture2D(tex, vtc, -0.5) * overrideColor * vcolor;\r\n#endif\r\n\r\n\t\tif (gl_FragColor.a \x3c 0.1) {\r\n\t\t\tdiscard;\r\n\t\t}\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fragmentShaderHUD"\x3e\x3c![CDATA[\r\n$fragmentShaderHUDBase\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fragmentShaderHUDHighlight"\x3e\x3c![CDATA[\r\n$fragmentShaderHUDBase\r\n  gl_FragColor \x3d vec4(1.0, 1.0, 1.0, 1.0);\r\n}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\r\n\x3csnippet name\x3d"vertexShaderOcclusionTestPixel"\x3e\x3c![CDATA[\r\n\tuniform mat4 proj;\r\n\tuniform mat4 view;\r\n\tuniform mat4 model;\r\n\tuniform mat4 modelNormal;\r\n\tuniform vec4 viewport;\r\n\tuniform vec3 camPos;\r\n\tuniform float polygonOffset;\r\n\r\n\tattribute vec3 $position;\r\n\tattribute vec3 $normal;\r\n\tattribute vec4 $auxpos1;\r\n\r\n\t$matchPixelCenter\r\n\r\n\tvoid main(void) {\r\n\t    vec4 centerOffset \x3d $auxpos1;\r\n\r\n\t    vec4 posProjCenter;\r\n\t    if (dot($position, $position) \x3e 0.0) {\r\n\t\t    $calcPosMatchPixelCenter\r\n\t\t} else {\r\n\t\t    posProjCenter \x3d vec4(1e038, 1e038, 1e038, 1.0);\r\n\t\t}\r\n\r\n\t\tgl_Position \x3d posProjCenter;\r\n\t\tgl_PointSize \x3d 1.0;\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3c/snippets\x3e\r\n'}});
define("dojo/_base/lang dojo/text!./HUDMaterial.xml ./internal/MaterialUtil ../lib/GLSLProgram ../lib/GLSLShader ../lib/ShaderVariations ../lib/VertexBufferLayout ../lib/Util ../lib/gl-matrix ../lib/webglConstants ../lib/RenderSlot".split(" "),function(F,J,s,K,G,H,L,y,C,x,D){var I=C.vec2d,w=C.vec3d,M=C.mat4d,A=y.assert,k=y.VertexAttrConstants,E={"bottom-left":[0,0],bottom:[0.5,0],"bottom-right":[1,0],left:[0,0.5],center:[0.5,0.5],right:[1,0.5],"top-left":[0,1],top:[0.5,1],"top-right":[1,1]};y=function(c,
z){s.basicMaterialConstructor(this,z);c=c||null;c.texCoordScale=c.texCoordScale||[1,1];c.occlusionTest=void 0!==c.occlusionTest?c.occlusionTest:!0;c.color=c.color||[1,1,1,1];c.screenMinMaxSize=c.screenMinMaxSize||[0,1E5];c.outlineColor=c.outlineColor||[1,1,1,1];c.outlineSize=c.outlineSize||0;c.textureIsSignedDistanceField=c.textureIsSignedDistanceField?1:0;c.distanceFieldBoundingBox=c.distanceFieldBoundingBox||[0.25,0.25,0.75,0.75];c.screenOffset?c.screenOffset.forEach(function(b,e){c.screenOffset[e]=
2*b}):c.screenOffset=[0,0];"string"===typeof c.anchorPos?(A(E[c.anchorPos],"HUDMaterial: invalid anchorPos specified"),c.anchorPos=E[c.anchorPos]):c.anchorPos||(c.anchorPos=E.center);null==c.shaderPolygonOffset&&(c.shaderPolygonOffset=1E-5);var t=new L([k.POSITION,k.NORMAL,k.UV0,k.COLOR,k.SIZE,k.AUXPOS1],[3,3,2,4,2,4],[x.FLOAT,x.FLOAT,x.FLOAT,x.UNSIGNED_BYTE,x.FLOAT,x.FLOAT]),h=t.getStride(),l=4*h;this.dispose=function(){};this.getParameterValues=function(){var b={color:c.color,texCoordScale:c.texCoordScale,
polygonOffset:c.polygonOffset,anchorPos:c.anchorPos,screenOffset:c.screenOffset,screenMinMaxSize:c.screenMinMaxSize,shaderPolygonOffset:c.shaderPolygonOffset,textureIsSignedDistanceField:c.textureIsSignedDistanceField,outlineColor:c.outlineColor,outlineSize:c.outlineSize,distanceFieldBoundingBox:c.distanceFieldBoundingBox};c.textureId&&(b.textureId=c.textureId);c.direction&&(b.direction=c.direction);return b};this.setParameterValues=function(b){for(var e in b)"textureId"===e&&A(c.textureId,"Can only change texture of material that already has a texture"),
"direction"===e&&A(c.direction,"Can only change direction of HUDMaterial which was initialized with a direction"),c[e]=b[e];this.notifyDirty("matChanged")};this.getParams=function(){return c};this.getOutputAmount=function(b){return 6*b*h};this.getVertexBufferLayout=function(){return t};this.fillInterleaved=function(b,e,d,g,f,n){g=s.fill;for(var u=t.getAttributes(),p=b.faces.indices[k.POSITION],q=b.vertexAttr[k.POSITION].data,a=n+u[k.POSITION].offset,r=0;r<p.length;++r){var m=3*p[r];g(q,m,f,a,e,3);
a+=h;g(q,m,f,a,e,3);a+=h;g(q,m,f,a,e,3);a+=h;g(q,m,f,a,e,3);a+=h;g(q,m,f,a,e,3);a+=h;g(q,m,f,a,e,3);a+=h}e=b.faces.indices[k.NORMAL];q=b.vertexAttr[k.NORMAL].data;a=n+u[k.NORMAL].offset;for(r=0;r<e.length;++r)m=3*e[r],g(q,m,f,a,d,3),a+=h,g(q,m,f,a,d,3),a+=h,g(q,m,f,a,d,3),a+=h,g(q,m,f,a,d,3),a+=h,g(q,m,f,a,d,3),a+=h,g(q,m,f,a,d,3),a+=h;a=n+u[k.UV0].offset;r=b.vertexAttr[k.UV0].data;null==r||3>=r.length?(d=m=0,e=c.texCoordScale[0],q=c.texCoordScale[1]):(m=b.vertexAttr[k.UV0].data[0],d=b.vertexAttr[k.UV0].data[1],
e=b.vertexAttr[k.UV0].data[2],q=b.vertexAttr[k.UV0].data[3]);e=Math.min(1.99999,e+1);q=Math.min(1.99999,q+1);for(r=0;r<p.length;++r)f[a]=m,f[a+1]=d,a+=h,f[a]=e,f[a+1]=d,a+=h,f[a]=e,f[a+1]=q,a+=h,f[a]=e,f[a+1]=q,a+=h,f[a]=m,f[a+1]=q,a+=h,f[a]=m,f[a+1]=d,a+=h;p=b.faces.indices[k.COLOR];d=b.vertexAttr[k.COLOR].data;a=4*(n+u[k.COLOR].offset);e=new Uint8Array(f.buffer);for(r=0;r<p.length;++r)m=4*p[r],g(d,m,e,a,null,4),a+=l,g(d,m,e,a,null,4),a+=l,g(d,m,e,a,null,4),a+=l,g(d,m,e,a,null,4),a+=l,g(d,m,e,a,
null,4),a+=l,g(d,m,e,a,null,4),a+=l;p=b.faces.indices[k.SIZE];m=b.vertexAttr[k.SIZE].data;a=n+u[k.SIZE].offset;for(r=0;r<p.length;++r)d=m[2*p[r]],e=m[2*p[r]+1],f[a]=d,f[a+1]=e,a+=h,f[a]=d,f[a+1]=e,a+=h,f[a]=d,f[a+1]=e,a+=h,f[a]=d,f[a+1]=e,a+=h,f[a]=d,f[a+1]=e,a+=h,f[a]=d,f[a+1]=e,a+=h;if(null!=b.faces.indices[k.AUXPOS1]&&null!=b.vertexAttr[k.AUXPOS1]){p=b.faces.indices[k.AUXPOS1];b=b.vertexAttr[k.AUXPOS1].data;a=n+u.auxpos1.offset;for(r=0;r<p.length;++r)m=4*p[r],g(b,m,f,a,null,4),a+=h,g(b,m,f,a,null,
4),a+=h,g(b,m,f,a,null,4),a+=h,g(b,m,f,a,null,4),a+=h,g(b,m,f,a,null,4),a+=h,g(b,m,f,a,null,4),a+=h}};var v=w.create(),n=w.create(),d=[0,0];this.intersect=function(b,e,l,g,f,h,u,p,q,a,r,m){if(m){e=b.getData().getVertexAttr()[k.POSITION];b=b.getData().getVertexAttr()[k.SIZE];A(3<=e.size);for(u=0;u<e.data.length/e.size;u++)if(p=u*e.size,w.set3(e.data[p],e.data[p+1],e.data[p+2],v),M.multiplyVec3(l,v,v),p=u*b.size,d[0]=b.data[p],d[1]=b.data[p+1],q.projectPoint(v,n),-1<n[0]){m=c.anchorPos;p=n[0]-1-(0<
m[0]?d[0]*m[0]:0);a=p+d[0];m=n[1]-1-(0<m[1]?d[1]*m[1]:0);var z=m+d[1];if(c.textureIsSignedDistanceField){var t=c.distanceFieldBoundingBox,s=c.outlineSize/2;p+=d[0]*t[0]-s;a-=d[0]*(1-t[2])-s;m+=d[1]*t[1]-s;z-=d[1]*(1-t[3])-s}g[0]>p&&(g[0]<a&&g[1]>m&&g[1]<z)&&(p=w.subtract(f,v,w.create()),a=w.length(p),w.scale(p,1/a),a=0.98*a/w.dist(f,h),r(a,p,-1,1,!0))}}};this.getGLMaterials=function(){return{color:N,depthShadowMap:void 0,normal:void 0,depth:void 0,highlight:O}};this.getAllTextureIds=function(){return[c.textureId]};
this._textureDirty=!1;this.setTextureDirty=function(){this._textureDirty=!0}};var N=function(c,k,t){function h(){return k.shaderVariators.HUDMaterial.getProgram([!!d.direction,!!d.worldScale,d.occlusionTest,d.textureIsSignedDistanceField])}s.basicGLMaterialConstructor(this,c);var l=D.TRANSPARENT_MATERIAL,v=D.OVERLAY,n=0,d=F.clone(c.getParams()),b=k.get("hudOcclusionTestPixel"),e=h();s.singleTextureGLMaterialConstructor(this,t,d);var B=[254/255,253/255,252/255];this.beginSlot=function(b){n=b;return d.occlusionTest?
b===l||b==v:b===l};this.getProgram=function(){return n===l&&d.occlusionTest?b:e};this.getAllPrograms=function(){return[b,e]};this.updateParameters=function(){var b=c.getParams();d.color=b.color;d.texCoordScale=b.texCoordScale;d.polygonOffset=b.polygonOffset;d.anchorPos=b.anchorPos;d.screenOffset=b.screenOffset;d.screenMinMaxSize=b.screenMinMaxSize;d.direction=b.direction;d.shaderPolygonOffset=b.shaderPolygonOffset;d.textureIsSignedDistanceField=b.textureIsSignedDistanceField;d.outlineColor=b.outlineColor;
d.outlineSize=b.outlineSize;this.updateTexture(b.textureId);e=h()};this.bind=function(g,f){c._textureDirty&&(this.renderTexture(g),c._textureDirty=!1);if(n===l&&d.occlusionTest)b.use(),b.uniform1f("polygonOffset",d.shaderPolygonOffset),b.uniform4fv("viewport",f.viewport),b.uniform4f("color",B[0],B[1],B[2],1),c.getVertexBufferLayout().enableVertexAttribArrays(g,b),g.depthFunc(g.LEQUAL);else{e.use();this.bindTexture(g,e);e.uniform1i("framebufferTex",1);g.activeTexture(g.TEXTURE1);g.bindTexture(g.TEXTURE_2D,
f.framebufferTex);g.activeTexture(g.TEXTURE0);e.uniform3fv("markerColor",B);e.uniform4fv("viewport",f.viewport);e.uniform4fv("overrideColor",d.color);e.uniform1f("pixelRatio",f.pixelRatio);e.uniform1f("polygonOffset",d.shaderPolygonOffset);d.textureIsSignedDistanceField&&(e.uniform4fv("outlineColor",d.outlineColor),e.uniform1f("outlineSize",d.outlineSize));if(d.worldScale){var h=[-1,-1],k=d.screenMinMaxSize,p=f.proj,q=f.viewport[2]/f.pixelRatio;k&&(0!==p[11]?(p=2*Math.atan(1/p[0]),q=2*(Math.tan(p/
2)/q),h[0]=k[0]*q,h[1]=k[1]*q):I.scale(k,2/(p[0]*q),h));e.uniform2fv("minMaxWorldSizeFactor",h)}d.direction&&e.uniform3fv("direction",d.direction);e.uniform2fv("texScale",d.texCoordScale);e.uniform2fv("screenOffset",d.screenOffset);e.uniform2fv("anchorPos",d.anchorPos);c.getVertexBufferLayout().enableVertexAttribArrays(g,e);d.polygonOffset&&(g.enable(g.POLYGON_OFFSET_FILL),g.polygonOffset(0,-4));g.web3DDefaultState.cullEnabled&&g.disable(g.CULL_FACE);g.enable(g.BLEND)}};this.release=function(g){n===
l&&d.occlusionTest?(g.depthFunc(g.LESS),c.getVertexBufferLayout().disableVertexAttribArrays(g,b)):(d.polygonOffset&&g.disable(g.POLYGON_OFFSET_FILL),g.web3DDefaultState.cullEnabled&&g.enable(g.CULL_FACE),g.disable(g.BLEND),c.getVertexBufferLayout().disableVertexAttribArrays(g,e))};this.bindView=function(c,f){var h=f.origin;n===l&&d.occlusionTest?(s.bindView(h,f.view,b),s.bindCamPos(h,f.viewInvTransp,b)):(s.bindView(h,f.view,e),s.bindCamPos(h,f.viewInvTransp,e))};this.bindInstance=function(c,f){n===
l&&d.occlusionTest?(b.uniformMatrix4fv("model",f.transformation),b.uniformMatrix4fv("modelNormal",f.transformationNormal)):e.uniformMatrix4fv("model",f.transformation)};this.getDrawMode=function(b){return n===l&&d.occlusionTest?b.POINTS:b.TRIANGLES}},O=function(c,k,t){function h(){return k.shaderVariators.HUDMaterialHighlight.getProgram([!!l.direction,!!l.worldScale,l.occlusionTest,l.textureIsSignedDistanceField])}s.basicGLMaterialConstructor(this,c);var l=F.clone(c.getParams()),v=k.get("hudOcclusionTestPixel"),
n=h();s.singleTextureGLMaterialConstructor(this,t,l);var d=[254/255,253/255,252/255];this.beginSlot=function(b){return b===D.OVERLAY};this.getProgram=function(){return n};this.getAllPrograms=function(){return[v,n]};this.updateParameters=function(){var b=c.getParams();l.color=b.color;l.texCoordScale=b.texCoordScale;l.polygonOffset=b.polygonOffset;l.anchorPos=b.anchorPos;l.screenOffset=b.screenOffset;l.screenMinMaxSize=b.screenMinMaxSize;l.direction=b.direction;l.shaderPolygonOffset=b.shaderPolygonOffset;
l.textureIsSignedDistanceField=b.textureIsSignedDistanceField;l.outlineColor=b.outlineColor;l.outlineSize=b.outlineSize;this.updateTexture(b.textureId);n=h()};this.bind=function(b,e){c._textureDirty&&(this.renderTexture(b),c._textureDirty=!1);n.use();this.bindTexture(b,n);n.uniform1i("framebufferTex",1);b.activeTexture(b.TEXTURE1);b.bindTexture(b.TEXTURE_2D,e.framebufferTex);b.activeTexture(b.TEXTURE0);n.uniform3fv("markerColor",d);n.uniform4fv("viewport",e.viewport);n.uniform4fv("overrideColor",
l.color);n.uniform1f("pixelRatio",e.pixelRatio);n.uniform1f("polygonOffset",l.shaderPolygonOffset);l.textureIsSignedDistanceField&&(n.uniform4fv("outlineColor",l.outlineColor),n.uniform1f("outlineSize",l.outlineSize));if(l.worldScale){var h=[-1,-1],g=l.screenMinMaxSize,f=e.proj,k=e.viewport[2]/e.pixelRatio;g&&(0!==f[11]?(f=2*Math.atan(1/f[0]),k=2*(Math.tan(f/2)/k),h[0]=g[0]*k,h[1]=g[1]*k):I.scale(g,2/(f[0]*k),h));n.uniform2fv("minMaxWorldSizeFactor",h)}l.direction&&n.uniform3fv("direction",l.direction);
n.uniform2fv("texScale",l.texCoordScale);n.uniform2fv("screenOffset",l.screenOffset);n.uniform2fv("anchorPos",l.anchorPos);c.getVertexBufferLayout().enableVertexAttribArrays(b,n);l.polygonOffset&&(b.enable(b.POLYGON_OFFSET_FILL),b.polygonOffset(0,-4));b.web3DDefaultState.cullEnabled&&b.disable(b.CULL_FACE);b.enable(b.BLEND)};this.release=function(b){l.polygonOffset&&b.disable(b.POLYGON_OFFSET_FILL);b.web3DDefaultState.cullEnabled&&b.enable(b.CULL_FACE);b.disable(b.BLEND);c.getVertexBufferLayout().disableVertexAttribArrays(b,
n)};this.bindView=function(b,c){var d=c.origin;s.bindView(d,c.view,n);s.bindCamPos(d,c.viewInvTransp,n)};this.bindInstance=function(b,c){n.uniformMatrix4fv("model",c.transformation)};this.getDrawMode=function(b){return b.TRIANGLES}};y.loadShaders=function(c,k,t,h){c._parse(J);var l=0<h.getParameter(h.MAX_VERTEX_TEXTURE_IMAGE_UNITS),s=new H("hud",["vertexShaderHUD","fragmentShaderHUD"],null,t,k,c,h);s.addBinaryShaderSnippetSuffix("Direction","Direction",[!0,!1]);s.addBinaryShaderSnippetSuffix("WorldScale",
"WorldScale",[!0,!1]);s.addDefine("OcclTest",l?"OCCL_TEST":"OCCL_PIXELSHADER");s.addDefine("SDF","SIGNED_DISTANCE_FIELD");t.shaderVariators.HUDMaterial=s;k=new H("hudHighlight",["vertexShaderHUD","fragmentShaderHUDHighlight"],null,t,k,c,h);k.addBinaryShaderSnippetSuffix("Direction","Direction",[!0,!1]);k.addBinaryShaderSnippetSuffix("WorldScale","WorldScale",[!0,!1]);k.addDefine("OcclTest",l?"OCCL_TEST":"OCCL_PIXELSHADER");k.addDefine("SDF","SIGNED_DISTANCE_FIELD");t.shaderVariators.HUDMaterialHighlight=
k;l=new G(h.VERTEX_SHADER,c.vertexShaderOcclusionTestPixel,h);c=new G(h.FRAGMENT_SHADER,c.fragmentShaderSimple,h);h=new K([l,c],h);t.add("hudOcclusionTestPixel",h)};return y});